<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Usar tipos de datos básicos</title><meta name="Language" content="es-es" /><meta name="System.Keywords" content="tipos de datos básicos" /><meta name="Microsoft.Help.Id" content="d7044936-5b8c-4def-858c-28a11ef70a97" /><meta name="Description" content="El Controlador Microsoft JDBC para SQL Server usa los tipos de datos básicos de JDBC para convertir los tipos de datos de SQL Server a un formato que el lenguaje de programación Java pueda entender y viceversa." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Usar tipos de datos básicos</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>El Controlador Microsoft JDBC para SQL Server usa los tipos de datos básicos de JDBC para convertir los tipos de datos de SQL Server a un formato que el lenguaje de programación Java pueda entender y viceversa. El controlador JDBC proporciona compatibilidad con la API de JDBC 4.0, que incluye los tipos de datos <span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span> y tipos de datos nacionales (Unicode), como <span sdata="langKeyword" value="NCHAR"><span class="keyword">NCHAR</span></span>, <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>, <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span> y <span sdata="langKeyword" value="NCLOB"><span class="keyword">NCLOB</span></span>.</p></div><h1 class="heading">Asignaciones de tipo de datos</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>La siguiente tabla muestra las asignaciones predeterminadas entre los tipos de datos de SQL Server básicos, JDBC y del lenguaje de programación Java:</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Tipos de SQL Server</p></th><th><p>Tipos de JDBC (Tipos de java.sql.)</p></th><th><p>Tipos del lenguaje Java</p></th></tr><tr><td><p>bigint</p></td><td><p>BIGINT</p></td><td><p>long</p></td></tr><tr><td><p>binary</p></td><td><p>BINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p>bit</p></td><td><p>BIT</p></td><td><p>boolean</p></td></tr><tr><td><p>char</p></td><td><p>CHAR</p></td><td><p>String</p></td></tr><tr><td><p>date</p></td><td><p>DATE</p></td><td><p>java.sql.Date</p></td></tr><tr><td><p>datetime</p></td><td><p>TIMESTAMP</p></td><td><p>java.sql.Timestamp</p></td></tr><tr><td><p>datetime2</p></td><td><p>TIMESTAMP</p></td><td><p>java.sql.Timestamp</p></td></tr><tr><td><p>datetimeoffset (2)</p></td><td><p>microsoft.sql.Types.DATETIMEOFFSET</p></td><td><p>microsoft.sql.DateTimeOffset</p></td></tr><tr><td><p>decimal</p></td><td><p>DECIMAL</p></td><td><p>java.math.BigDecimal</p></td></tr><tr><td><p>float</p></td><td><p>DOUBLE</p></td><td><p>double</p></td></tr><tr><td><p>image</p></td><td><p>LONGVARBINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p>int</p></td><td><p>INTEGER</p></td><td><p>int</p></td></tr><tr><td><p>money</p></td><td><p>DECIMAL</p></td><td><p>java.math.BigDecimal</p></td></tr><tr><td><p>nchar</p></td><td><p>CHAR</p><p>SQLXML (Java SE 6.0)</p></td><td><p>String</p></td></tr><tr><td><p>ntext</p></td><td><p>LONGVARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String</p></td></tr><tr><td><p>numeric</p></td><td><p>NUMERIC</p></td><td><p>java.math.BigDecimal</p></td></tr><tr><td><p>nvarchar</p></td><td><p>VARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String</p></td></tr><tr><td><p>nvarchar(max)</p></td><td><p>VARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String</p></td></tr><tr><td><p>real</p></td><td><p>REAL</p></td><td><p>float</p></td></tr><tr><td><p>smalldatetime</p></td><td><p>TIMESTAMP</p></td><td><p>java.sql.Timestamp</p></td></tr><tr><td><p>smallint</p></td><td><p>SMALLINT</p></td><td><p>short</p></td></tr><tr><td><p>smallmoney</p></td><td><p>DECIMAL</p></td><td><p>java.math.BigDecimal</p></td></tr><tr><td><p>text</p></td><td><p>LONGVARCHAR</p></td><td><p>String</p></td></tr><tr><td><p>time</p></td><td><p>TIME (1)</p></td><td><p>java.sql.Time (1)</p></td></tr><tr><td><p>timestamp</p></td><td><p>BINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p>tinyint</p></td><td><p>TINYINT</p></td><td><p>short</p></td></tr><tr><td><p>udt</p></td><td><p>VARBINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p>uniqueidentifier</p></td><td><p>CHAR</p></td><td><p>String</p></td></tr><tr><td><p>varbinary</p></td><td><p>VARBINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p>varbinary(max)</p></td><td><p>VARBINARY</p></td><td><p>byte[]</p></td></tr><tr><td><p /></td><td><p /></td><td><p /></td></tr><tr><td><p>varchar</p></td><td><p>VARCHAR</p></td><td><p>String</p></td></tr><tr><td><p>varchar(max)</p></td><td><p>VARCHAR</p></td><td><p>String</p></td></tr><tr><td><p>xml</p></td><td><p>LONGVARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String</p><p>SQLXML</p></td></tr></table></div><p>(1) Para utilizar java.sql.Time con el tipo de hora de SQL Server, debe establecer la propiedad de conexión <span sdata="langKeyword" value="sendTimeAsDatetime"><span class="keyword">sendTimeAsDatetime</span></span> en FALSE.</p><p>(2) Puede tener acceso mediante programación a los valores de <span sdata="langKeyword" value="datetimeoffset"><span class="keyword">datetimeoffset</span></span> con <span sdata="link"><a href="20bbeacd-ccca-4a46-8184-ff941ae2ec5f.htm">Clase DateTimeOffset</a></span>.</p><p>El tipo de datos sqlvariant de SQL Server no es compatible actualmente con el controlador JDBC. Si se usa una consulta para recuperar datos de una tabla que contenga una columna del tipo de datos sqlvariant, se producirá una excepción.</p><p>Las siguientes secciones proporcionan ejemplos de cómo puede usar el controlador JDBC y los tipos de datos básicos. Si desea obtener un ejemplo detallado sobre cómo usar los tipos de datos básicos en una aplicación de Java, consulte <span sdata="link"><a href="59ac80cf-fc66-4493-933d-38e479c5f54d.htm">Ejemplo de tipos de datos básicos</a></span>.</p></div><h1 class="heading">Recuperar datos como una cadena</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Si tiene que recuperar datos de un origen de datos que se asignen a cualquiera de los tipos de datos básicos de JDBC para verlos como una cadena, o si no son necesarios datos de tipos muy marcados, puede usar el método <a href="f81dde01-d328-4b32-8871-1efac645b68e.htm">getString</a> de la clase <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>, como en el siguiente ejemplo:</p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>String SQL = "SELECT TOP 10 * FROM Person.Contact";
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery(SQL);

while (rs.next()) {
   System.out.println(rs.getString(4) + " " + rs.getString(6));
}
rs.close();
stmt.close();

</pre></span></div></div></div><h1 class="heading">Recuperar datos por tipos de datos</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Si tiene que recuperar datos de un origen de datos y sabe el tipo de datos que se van a recuperar, use uno de los métodos <b>get&lt;Type&gt;</b> de la clase <b>SQLServerResultSet</b>, también conocidos como <span class="term">métodos de captador</span>. Con los métodos <b>get&lt;Type&gt;</b>, puede usar un nombre de columna o un índice de columna, como en el siguiente ejemplo:</p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>ResultSet rs = stmt.executeQuery("SELECT lname, job_id FROM employee
   WHERE (lname = 'Brown')");
rs.next();
short empJobID = rs.getShort("job_id");
rs.close();
stmt.close();

</pre></span></div></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Los métodos con escala <b>getUnicodeStream</b> y <b>getBigDecimal</b> están obsoletos y el controlador JDBC no los admite.</p></div></div><h1 class="heading">Actualizar datos por tipos de datos</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>Si tiene que actualizar el valor de un campo en un origen de datos, use uno de los métodos <b>update&lt;Type&gt;</b> de la clase <b>SQLServerResultSet</b>. En el siguiente ejemplo, se usa el método <a href="2bb0319e-12cb-4604-a7e3-b22a24b02296.htm">updateInt</a> en conjunción con el método <a href="cfced0ca-a281-40dc-8d2f-370d5f0bf12b.htm">updateRow</a> para actualizar los datos del origen de datos:</p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE); 
ResultSet rs = stmt.executeQuery("SELECT lname, job_id FROM employee
   WHERE (lname = 'Brown')");
rs.next();
short empJobID = rs.getInt(2);
empJobID++;
rs.first();
rs.updateInt(2, empJobID);
rs.updateRow();
rs.close();
stmt.close();

</pre></span></div></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>El controlador JDBC no puede actualizar una columna SQL Server con un nombre de columna que tenga más de 127 caracteres de largo. Si se intenta una actualización a una columna cuyo nombre tenga más de 127 caracteres, se genera una excepción.</p></div></div><h1 class="heading">Actualizar datos mediante una consulta con parámetros</h1><div id="sectionSection4" class="section" name="collapseableSection" style=""><p>Si tiene que actualizar datos de un origen de datos mediante el uso de una consulta con parámetros, puede establecer el tipo de datos de los parámetros con los métodos <b>set&lt;Type&gt;</b> de la clase <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a>, también conocidos como <span class="term">métodos de establecedor</span>. En el siguiente ejemplo, se usa el método <a href="bd4e4085-f704-4a73-b6a7-7d443d564728.htm">prepareStatement</a> para precompilar la consulta con parámetros, y luego el método <a href="25dabdc9-c60f-485a-87eb-306067964765.htm">setString</a> para establecer el valor de cadena del parámetro antes de llamar al método <a href="ca534c6b-ef4d-4ae8-8cc3-514728623cff.htm">executeUpdate</a>.</p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>PreparedStatement pstmt = con.prepareStatement("UPDATE employee SET
   fname = ? WHERE (lname = 'Brown')");
String first = "Bob";
pstmt.setString(1, first);
int rowCount = pstmt.executeUpdate();
pstmt.close();

</pre></span></div></div><p>Para obtener más información sobre consultas con parámetros, vea <span sdata="link"><a href="3202b88f-ce13-44dd-982c-c6a3b0260378.htm">Usar una instrucción SQL con parámetros</a></span>.</p></div><h1 class="heading">Pasar de parámetros a un procedimiento almacenado</h1><div id="sectionSection5" class="section" name="collapseableSection" style=""><p>Si tiene que pasar parámetros de tipo a un procedimiento almacenado, puede establecerlos por índice o por nombre mediante el uso de uno de los métodos <b>set&lt;Type&gt;</b> de la clase <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>. En el siguiente ejemplo, se usa el método <a href="265b024c-898a-4bd0-98b5-f06076717b9e.htm">prepareCall</a> para configurar la llamada al procedimiento almacenado, y luego el método <a href="f38b97b5-d4f0-4f74-a33d-740241a85842.htm">setString</a> para establecer el parámetro para la llamada antes de llamar al método <a href="599cf463-e19f-4baa-bacb-513cad7c6cd8.htm">executeQuery</a>. </p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>CallableStatement cstmt = con.prepareCall("{call employee_jobid(?)}");
String lname = "Brown";
cstmt.setString(1, lname);
Resultset rs = cstmt.executeQuery();
rs.close();
cstmt.close();

</pre></span></div></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>En este ejemplo, se devuelve un conjunto de resultados con los resultados de la ejecución del procedimiento almacenado. </p></div><p>Para obtener más información sobre el uso del controlador JDBC con procedimientos almacenados y parámetros de entrada, consulte <span sdata="link"><a href="8f491b70-7d1b-42bd-964f-9a8b86af5eaa.htm">Usar un procedimiento almacenado con parámetros de entrada</a></span>.</p></div><h1 class="heading">Recuperación de parámetros desde un procedimiento almacenado</h1><div id="sectionSection6" class="section" name="collapseableSection" style=""><p>Si tiene que recuperar parámetros desde un procedimiento almacenado, primero debe registrar un parámetro de salida por el nombre o el índice con el método <a href="82f8d608-efc1-4af8-a985-ec25d19420aa.htm">registerOutParameter</a> de la clase <b>SQLServerCallableStatement</b> y, a continuación, asignar el parámetro de salida devuelto a una variable adecuada después de haber ejecutado la llamada al procedimiento almacenado. En el siguiente ejemplo, se usa el método <b>prepareCall</b> para configurar la llamada al procedimiento almacenado, el método <b>registerOutParameter</b> para configurar el parámetro de salida y el método <a href="f38b97b5-d4f0-4f74-a33d-740241a85842.htm">setString</a> para establecer el parámetro para la llamada antes de llamar al método <b>executeQuery</b>. El valor que devuelve el parámetro de salida del procedimiento almacenado se recupera con el método <a href="9e3c51bc-7285-4f28-92c8-cfa05e49da9e.htm">getShort</a>.</p><div name="snippetGroup"><div class="sampleCode"><span codeLanguage="Java"><pre>CallableStatement cstmt = con.prepareCall("{call employee_jobid (?, ?)}");
cstmt.registerOutParameter(2, java.sql.Types.SMALLINT);
String lname = "Brown";
cstmt.setString(1, lname);
Resultset rs = cstmt.executeQuery();
short empJobID = cstmt.getShort(2);
rs.close();
cstmt.close();

</pre></span></div></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Además del parámetro de salida devuelto, puede que también se devuelva un conjunto de resultados con los resultados de ejecución del procedimiento almacenado.</p></div><p>Para obtener más información sobre el uso del controlador JDBC con procedimientos almacenados y parámetros de salida, consulte <span sdata="link"><a href="1c006f27-7e99-43d5-974c-7b782659290c.htm">Usar un procedimiento almacenado con parámetros de salida</a></span>.</p></div><span id="seeAlsoSpan"><h1 class="heading">Vea también</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Describir los tipos de datos del controlador JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Enviar <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dLe%20agradecemos%20sus%20comentarios.%20Los%20equipos%20de%20desarrolladores%20usan%20estos%20comentarios%20para%20mejorar%20la%20documentación.%20Mientras%20revisamos%20los%20comentarios,%20es%20posible%20que%20le%20enviemos%20un%20correo%20electrónico%20para%20solicitarle%20alguna%20aclaración%20o%20comentarios%20sobre%20una%20posible%20solución.%20No%20usamos%20su%20dirección%20de%20correo%20electrónico%20para%20ningún%20otro%20propósito%20y%20ésta%20se%20borra%20una%20vez%20finalizada%20la%20revisió.%0\APara%20obtener%20más%20información%20acerca%20de%20las%20directivas%20de%20privacidad%20de%20Microsoft,%20vea%20http://privacy.microsoft.com/es-es/default.aspx.%0\A%0\d','Comentarios%20del cliente');">comentarios de </a> acerca de este tema Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Todos los derechos reservados.</a></p></span></div></div></body></html>