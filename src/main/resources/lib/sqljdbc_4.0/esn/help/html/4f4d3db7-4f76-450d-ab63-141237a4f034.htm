<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Descripción de los tipos de cursor</title><meta name="Language" content="es-es" /><meta name="System.Keywords" content="tipos de cursor" /><meta name="Microsoft.Help.Id" content="4f4d3db7-4f76-450d-ab63-141237a4f034" /><meta name="Description" content="Las operaciones de una base de datos relacional actúan en un conjunto completo de filas. El conjunto de filas que devuelve una instrucción SELECT está compuesto por todas las filas que satisfacen las condiciones de la cláusula WHERE de la instrucción." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Descripción de los tipos de cursor</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Las operaciones de una base de datos relacional actúan en un conjunto completo de filas. El conjunto de filas que devuelve una instrucción SELECT está compuesto por todas las filas que satisfacen las condiciones de la cláusula WHERE de la instrucción. Este conjunto completo de filas que devuelve la instrucción se conoce como conjunto de resultados. Las aplicaciones no siempre funcionan de forma eficaz con el conjunto de resultados completo si lo toman como una unidad. Estas aplicaciones necesitan un mecanismo que funcione con una fila o un pequeño bloque de filas cada vez. Los cursores son una extensión de los conjuntos de resultados que proporcionan dicho mecanismo. </p><p>Para ampliar el procesamiento de los conjuntos de resultados, los cursores:</p><ul><li><p>Permiten situarse en filas específicas del conjunto de resultados.</p></li><li><p>Recuperan una fila o un bloque de filas de la posición actual en el conjunto de resultados.</p></li><li><p>Admiten modificaciones de los datos de las filas en la posición actual del conjunto de resultados.</p></li><li><p>Admiten diferentes grados de visibilidad para los cambios que otros usuarios realizan en la información de la base de datos que se presenta en el conjunto de resultados.</p></li></ul><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Para obtener una descripción completa de los tipos de cursor de SQL Server, vea el tema "Cursor Types (Database Engine)" en los Libros en pantalla de SQL Server</p></div><p>La especificación JDBC proporciona compatibilidad con los cursores de solo avance y los cursores desplazables que son sensibles o no a los cambios que realizan otros trabajos, y pueden ser de solo lectura o actualizables. La clase <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> del Controlador Microsoft JDBC para SQL Server proporciona esta funcionalidad.</p></div><h1 class="heading">Notas</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>El controlador JDBC es compatible con los siguientes tipos de cursor:</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Tipo de cursor </p><p>de conjunto de resultados</p></th><th><p>Tipo de cursor de SQL Server</p></th><th><p>Características</p></th><th><p>Método de </p><p>selección</p></th><th><p>Almacenamiento en búfer</p><p>de respuesta</p></th><th><p>Descripción</p></th></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>N/D</p></td><td><p>Solo avance y solo lectura</p></td><td><p>directo</p></td><td><p>completo</p></td><td><p>La aplicación tiene que hacer un único paso (hacia delante) a través del conjunto de resultados. Éste es el comportamiento predeterminado, que es el mismo que el de un cursor TYPE_SS_DIRECT_FORWARD_ONLY. El controlador lee todo el conjunto de resultados del servidor en una memoria durante la ejecución de la instrucción. </p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>N/D</p></td><td><p>Solo avance y solo lectura</p></td><td><p>directo</p></td><td><p>adaptable</p></td><td><p>La aplicación tiene que hacer un único paso (hacia delante) a través del conjunto de resultados. Se comporta igual que un cursor TYPE_SS_DIRECT_FORWARD_ONLY. El controlador lee las filas del servidor a medida que la aplicación las solicita y, por tanto, reduce el uso de la memoria del lado cliente.</p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>Avance rápido</p></td><td><p>Solo avance y solo lectura</p></td><td><p>cursor</p></td><td><p>N/D</p></td><td><p>La aplicación tiene que hacer un único paso (hacia delante) a través del conjunto de resultados mediante un cursor de servidor. Se comporta igual que un cursor TYPE_SS_SERVER_CURSOR_FORWARD_ONLY.</p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_UPDATABLE)</p></td><td><p>Dinámico (de solo avance)</p></td><td><p>Solo avance, actualizable</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>La aplicación tiene que hacer un único paso (hacia delante) a través del conjunto de resultados para actualizar una o varias filas. </p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p><p>De forma predeterminada, el tamaño de captura se fija cuando la aplicación llama al método <a href="233bf4f8-4758-42d0-a80b-33e34fa78027.htm">setFetchSize</a> del objeto <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>. </p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>El controlador JDBC proporciona una característica de almacenamiento en búfer adaptable que le permite recuperar los resultados de la ejecución de una instrucción de SQL Server a medida que la aplicación los necesita, en lugar de todos a la vez. Por ejemplo, si la aplicación tuviera que recuperar una cantidad de datos demasiado grande para la memoria de la aplicación, el almacenamiento en búfer adaptable permite a la aplicación cliente recuperar ese valor como un flujo. </p><p>El comportamiento predeterminado del controlador es "<span sdata="langKeyword" value="adaptive"><span class="keyword">adaptive</span></span>". Sin embargo, para obtener el almacenamiento en búfer para conjuntos de resultados adaptables de solo avance, la aplicación tiene que llamar al método <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> del objeto <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> proporcionando un valor <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> "<span sdata="langKeyword" value="adaptive&quot;"><span class="keyword">adaptive"</span></span>. Como código muestra, vea <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Actualizar un ejemplo de datos grandes</a></span>.</p></div></td></tr><tr><td><p>TYPE_SCROLL_INSENSITIVE</p></td><td><p>Estático</p></td><td><p>Desplazable y no actualizable</p><p>Las actualizaciones, inserciones y eliminaciones en filas externas no son visibles.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>La aplicación requiere una instantánea de base de datos. El conjunto de resultados no es adaptable. Solo es compatible CONCUR_READ_ONLY.  Todos los demás tipos de simultaneidad producirán una excepción cuando se usen con este tipo de cursor.</p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p></td></tr><tr><td><p>TYPE_SCROLL_SENSITIVE</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Conjunto de claves</p></td><td><p>Desplazable, de solo lectura. Las actualizaciones de filas externas son visibles y las eliminaciones aparecen como datos que faltan.</p><p>Las inserciones en filas externas no son visibles. </p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>La aplicación tiene que ver datos cambiados solo para las filas existentes.</p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p></td></tr><tr><td><p>TYPE_SCROLL_SENSITIVE</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Conjunto de claves</p></td><td><p>Desplazable, actualizable. </p><p>Las actualizaciones de filas externas e internas son visibles y las eliminaciones aparecen como datos que faltan; las inserciones no son visibles.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>La aplicación puede cambiar datos de las filas existentes mediante el objeto <b>ResultSet</b>. La aplicación debe poder ver también los cambios en filas hechos por otros desde fuera del objeto <b>ResultSet</b>.</p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p></td></tr><tr><td><p>TYPE_SS_DIRECT_FORWARD_ONLY</p></td><td><p>N/D</p></td><td><p>Solo avance y solo lectura</p></td><td><p>N/D</p></td><td><p>completo o adaptable</p></td><td><p>Valor entero = 2003. Proporciona un cursor de solo lectura del lado cliente que está completamente almacenado en búfer. No se crea ningún cursor de servidor.</p><p>Solo es compatible el tipo de simultaneidad CONCUR_READ_ONLY. Todos los demás tipos de simultaneidad producen una excepción cuando se usan con este tipo de cursor.</p></td></tr><tr><td><p>TYPE_SS_SERVER_CURSOR_FORWARD_ONLY</p></td><td><p>Avance rápido</p></td><td><p>Solo avance</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valor entero = 2004. Rápido, con acceso a todos los datos mediante un cursor de servidor. Es actualizable cuando se usa con un tipo de simultaneidad CONCUR_UPDATABLE.</p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p><p>Para obtener el almacenamiento en búfer adaptable para este caso, la aplicación tiene que llamar explícitamente al método <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> del objeto <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> proporcionando un valor <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> "<span sdata="langKeyword" value="adaptive&quot;"><span class="keyword">adaptive"</span></span>. Como código muestra, vea <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Actualizar un ejemplo de datos grandes</a></span>.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_STATIC</p></td><td><p>Estático</p></td><td><p>No se reflejan las actualizaciones de los demás usuarios.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valor entero = 1004. La aplicación requiere una instantánea de base de datos. Este es el sinónimo específico de SQL Server para JDBC TYPE_SCROLL_INSENSITIVE y tiene el mismo comportamiento de configuración de simultaneidad.</p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_KEYSET</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Conjunto de claves</p></td><td><p>Desplazable, de solo lectura. Las actualizaciones de filas externas son visibles y las eliminaciones aparecen como datos que faltan.</p><p>Las inserciones en filas externas no son visibles.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valor entero = 1005. La aplicación solo tiene que ver los datos cambiados para las filas existentes. Este es el sinónimo específico de SQL Server para JDBC TYPE_SCROLL_SENSITIVE y tiene el mismo comportamiento de configuración de simultaneidad.</p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_KEYSET</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Conjunto de claves</p></td><td><p>Desplazable, actualizable. </p><p>Las actualizaciones de filas externas e internas son visibles y las eliminaciones aparecen como datos que faltan; las inserciones no son visibles.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valor entero = 1005. La aplicación solo tiene que ver los datos cambiados para las filas existentes. Este es el sinónimo específico de SQL Server para JDBC TYPE_SCROLL_SENSITIVE y tiene el mismo comportamiento de configuración de simultaneidad.</p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_DYNAMIC</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Dinámico</p></td><td><p>Desplazable, de solo lectura. </p><p>Las actualizaciones e inserciones de las filas externas son visibles, y las eliminaciones aparecen como datos que faltan de forma transitoria en el búfer de captura actual. </p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valor entero = 1006. La aplicación debe ver los datos cambiados para las filas existentes, así como las filas insertadas y eliminadas durante la duración del cursor.</p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_DYNAMIC</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Dinámico</p></td><td><p>Desplazable, actualizable. </p><p>Las actualizaciones e inserciones de las filas externas e internas son visibles, y las eliminaciones aparecen como datos que faltan de forma transitoria en el búfer de captura actual.</p></td><td><p>N/D</p></td><td><p>N/D</p></td><td><p>Valor entero = 1006. La aplicación puede cambiar datos para las filas existentes, o insertar o eliminar filas, mediante el objeto <b>ResultSet</b>. La aplicación debe poder ver también los cambios, inserciones y eliminaciones en filas hechos por otros desde fuera del objeto <b>ResultSet</b>.</p><p>Las filas son recuperadas del servidor en bloques que son especificados por el tamaño de captura.</p></td></tr></table></div></div><h1 class="heading">Colocación de los cursores</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Los cursores TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY y TYPE_SS_SERVER_CURSOR_FORWARD_ONLY solo son compatibles con el método de colocación <a href="60248447-6908-4036-a779-a501453cd553.htm">next</a>.</p><p>El cursor TYPE_SS_SCROLL_DYNAMIC no admite los métodos <a href="638e8148-8ca0-4e1f-9ec2-04a11bc9809b.htm">absolute</a> y <a href="a266e3bc-05c2-44e2-9346-125ae6780216.htm">getRow</a>. El método <b>absolute</b> puede conseguirse aproximadamente mediante una combinación de llamadas a los métodos <a href="67ed9447-7b10-4c87-98e7-f4c2e2470b3a.htm">first</a> y <a href="2bcdbb69-95fd-4ae8-8488-1a75a91fe2e0.htm">relative</a> de los cursores dinámicos.</p><p>Solo los cursores TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY, TYPE_SS_SERVER_CURSOR_FORWARD_ONLY, TYPE_SS_SCROLL_KEYSET y TYPE_SS_SCROLL_STATIC admiten el método  <b>getRow</b>. El método <b>getRow</b> con todos los tipos de cursores de solo avance devuelve el número de filas leídas hasta el cursor.</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Cuando una aplicación hace una llamada que no se admite para colocar un cursor o hace una llamada que no se admite al método <b>getRow</b>, se inicia una excepción con el mensaje "La operación solicitada no es compatible con este tipo de cursor".</p></div><p>Solo los cursores TYPE_SS_SCROLL_KEYSET y los cursores TYPE_SCROLL_SENSITIVE equivalentes exponen las filas eliminadas. Si el cursor se coloca en una fila eliminada, los valores de las columnas no están disponibles, y el método <a href="9c6db315-e614-4604-b020-41af6a214cc1.htm">rowDeleted</a> devuelve "true". Las llamadas a los métodos <b>get&lt;Type&gt;</b> provocan que se inicie una excepción y que se muestre un mensaje similar a "No se puede obtener un valor de una fila eliminada". Las filas eliminadas no se pueden actualizar. Si intenta llamar a un método <b>update&lt;Type&gt;</b> con una fila eliminada, se inicia una excepción y se muestra un mensaje similar a "Una fila eliminada no se puede actualizar". El cursor TYPE_SS_SCROLL_DYNAMIC tiene el mismo comportamiento hasta que el cursor se mueve fuera del búfer de captura actual.</p><p>Los cursores dinámicos y hacia delante exponen las filas eliminadas de un modo similar, pero solo mientras siguen estando accesibles en el búfer de captura. Con los cursores hacia delante, esto es bastante sencillo. Con los cursores dinámicos resulta más complejo si el tamaño de la lectura es mayor que 1. Una aplicación puede mover el cursor hacia delante y hacia atrás dentro de la ventana que se define en el búfer de captura, pero la fila eliminada desaparecerá cuando el búfer de captura original en el que se actualizó permanezca.  Si una aplicación no desea ver las filas eliminadas de forma transitoria mediante cursores dinámicos, se debería usar una lectura relativa (0).</p><p>Si los valores de la clave de una fila de cursores TYPE_SS_SCROLL_KEYSET o TYPE_SCROLL_SENSITIVE se actualizan con el cursor, la fila conserva su posición original en el conjunto de resultados, independientemente de si la fila actualizada cumple los criterios de selección del cursor. Si la fila se actualizó fuera del cursor, una fila eliminada aparecerá en la posición original de la fila, pero solamente aparecerá en el cursor si otra fila con los valores de la nueva clave estaba presente en el cursor y se ha eliminado desde entonces. </p><p>Con los cursores dinámicos, las filas actualizadas conservarán su posición dentro del búfer de captura hasta que el búfer de captura que permanece defina la ventana.  Las filas actualizadas podrían reaparecer después en posiciones diferentes dentro del conjunto de resultados, o podrían desaparecer por completo. Las aplicaciones que tienen que evitar incoherencias transitorias en el conjunto de resultados deberían usar un tamaño de lectura de 1 (de forma predeterminada es de 8 filas con simultaneidad de CONCUR_SS_SCROLL_LOCKS y de 128 filas con otras).</p></div><h1 class="heading">Conversión de cursores</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>En ocasiones, SQL Server puede elegir implementar un tipo de cursor que no sea el solicitado, lo que se conoce como conversión de cursor implícita (o degradación del cursor). Para obtener más información sobre la conversión de cursor implícita, vea el tema "Conversiones de cursor implícitas" en los Libros en pantalla de SQL Server.</p><p>Con SQL Server 2000, cuando actualiza los datos a través de <b>ResultSet.TYPE_SCROLL_SENSITIVE</b> y del conjunto de resultados <b>ResultSet.CONCUR_UPDATABLE</b>, se inicia una excepción con un mensaje "El cursor es READ ONLY". Esta excepción se debe a que SQL Server 2000 ha realizado una conversión implícita del cursor para ese conjunto de resultados y no devolvió el cursor actualizado que se ha solicitado.</p><p>Como solución alternativa para este problema, puede elegir una de las siguientes dos soluciones:</p><ul><li><p>Asegurarse de que la tabla subyacente tiene una clave principal</p></li><li><p>Use <a href="d87afd89-3e75-402c-b844-1b434eb258df.htm">SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC</a> en lugar de <b>ResultSet.TYPE_SCROLL_SENSITIVE</b> mientras crea una instrucción.</p></li></ul></div><h1 class="heading">Actualización de cursores</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>Las actualizaciones en contexto se admiten para los cursores cuyo tipo y simultaneidad lo permiten. Si el cursor no está colocado en una fila actualizable en el conjunto de resultados (ninguna llamada el método <b>get&lt;Type&gt;</b> tuvo éxito), una llamada a un método <b>update&lt;Type&gt;</b> iniciará una excepción y se mostrará el mensaje "El conjunto de resultados no tiene fila actual". La especificación de JDBC indica que se inicia una excepción cuando se llama a un método de actualización con una columna de un cursor que sea CONCUR_READ_ONLY. En las situaciones en las que la fila no es actualizable, por ejemplo debido a un conflicto de simultaneidad optimista como una actualización o eliminación en competencia, la excepción podría no iniciarse hasta que se llamara a <a href="363d1008-1396-4fc0-8e27-c9ba2499e7f1.htm">insertRow</a>, <a href="cfced0ca-a281-40dc-8d2f-370d5f0bf12b.htm">updateRow</a> o <a href="aa04a644-c7c2-4738-8b6e-7fea566d2c16.htm">deleteRow</a>.</p><p>Después de llamar a <b>update&lt;Type&gt;</b>, <b>get&lt;Type&gt;</b> no puede tener acceso a la columna afectada hasta que se haya llamado a <b>updateRow</b> o <a href="2ecacca4-f7bc-4f5d-886a-da7747fdccae.htm">cancelRowUpdates</a>. Esto evita los problemas que se producen porque una columna se actualiza con un tipo diferente del que devuelve el servidor, y las siguientes llamadas podrían invocar conversiones de tipos del lado cliente que dan resultados imprecisos. Las llamadas a <b>get&lt;Type&gt;</b> iniciarán una excepción con un mensaje similar a "No se puede tener acceso a las columnas actualizadas hasta que se haya llamado a updateRow() o a cancelRowUpdates()".</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Si se llama al método <b>updateRow</b> cuando no se hayan actualizado las columnas, el controlador JDBC iniciará una excepción con el mensaje  "Se llamó a updateRow() cuando no se han actualizado las columnas".</p></div><p>Después de llamar a <a href="f3c54bfe-d5b7-4f6e-ae6c-3e8954e5b1c9.htm">moveToInsertRow</a>, se iniciará una excepción si se llama a cualquier otro método que no sea <b>get&lt;Type&gt;</b>, <b>update&lt;Type&gt;</b>, <b>insertRow,</b> y otros métodos de colocación de los cursores (incluido <a href="9a7c754c-2d72-4207-b3bd-2afc6047fb3d.htm">moveToCurrentRow</a>) en el conjunto de resultados. El método <b>moveToInsertRow</b> coloca de hecho el conjunto de resultados en el modo de inserción, y los métodos de colocación de los cursores terminan dicho modo. Las llamadas para colocar cursores relativos mueven el cursor en relación con la posición en que estaba antes de que se llamara a <b>moveToInsertRow</b>. Después de las llamadas para colocar cursores, la posición final del cursor de destino se convierte en la nueva posición del cursor.</p><p>Si la llamada para colocar un cursor que se realizó mientras se estaba en el modo de inserción no tiene éxito, la posición del cursor después de la llamada que no tuvo éxito es la posición original del cursor antes de que se llamara a <b>moveToInsetRow</b>. Si <b>insertRow</b> da error, el cursor permanece en la fila de inserción y en el modo de inserción.</p><p>Las columnas de la fila de inserción están inicialmente en un estado sin inicializar. Las llamadas al método <b>update&lt;Type&gt;</b> establecen el estado de las columnas como inicializado. Una llamada al método <b>get&lt;Type&gt;</b> para una columna sin inicializar inicia una excepción. Una llamada al método <b>insertRow</b> devuelve todas las columnas de la fila de inserción en un estado sin inicializar.</p><p>Si alguna columna está sin inicializar cuando se llama al método <b>insertRow</b>, se inserta el valor predeterminado para la columna. Si no hay ningún valor predeterminado pero la columna admite valores NULL, se inserta el valor NULL. Si no hay ningún valor predeterminado y la columna no admite valores NULL, el servidor devolverá un error y se iniciará una excepción.</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p /><p>Las llamadas al método <b>getRow</b> devuelven 0 cuando se está en modo de inserción. </p><p>El controlador JDBC no es compatible con las eliminaciones o actualizaciones por posición. Según la especificación de JDBC, el método <a href="3f3ec4f2-103a-4e16-9206-c5bd8639f946.htm">setCursorName</a> no tiene ningún efecto y el método <a href="e5b3af67-423a-4551-a4c6-a4bc076bd504.htm">getCursorName</a> iniciará una excepción si se llama. </p><p>Los cursores estáticos y de solo lectura nunca son actualizables. </p><p>SQL Server restringe los cursores de servidor a un solo conjunto de resultados. Si un lote o procedimiento almacenado contiene varias instrucciones, se debe usar un cursor de cliente de solo lectura y de solo avance.</p></div></div><span id="seeAlsoSpan"><h1 class="heading">Vea también</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="9ed5ad41-22e0-4e4a-8a79-10512db60d50.htm">Administrar conjuntos de resultados con el controlador JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Enviar <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dLe%20agradecemos%20sus%20comentarios.%20Los%20equipos%20de%20desarrolladores%20usan%20estos%20comentarios%20para%20mejorar%20la%20documentación.%20Mientras%20revisamos%20los%20comentarios,%20es%20posible%20que%20le%20enviemos%20un%20correo%20electrónico%20para%20solicitarle%20alguna%20aclaración%20o%20comentarios%20sobre%20una%20posible%20solución.%20No%20usamos%20su%20dirección%20de%20correo%20electrónico%20para%20ningún%20otro%20propósito%20y%20ésta%20se%20borra%20una%20vez%20finalizada%20la%20revisió.%0\APara%20obtener%20más%20información%20acerca%20de%20las%20directivas%20de%20privacidad%20de%20Microsoft,%20vea%20http://privacy.microsoft.com/es-es/default.aspx.%0\A%0\d','Comentarios%20del cliente');">comentarios de </a> acerca de este tema Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Todos los derechos reservados.</a></p></span></div></div></body></html>