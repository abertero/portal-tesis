<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Descripción de las conversiones de tipos de datos</title><meta name="Language" content="es-es" /><meta name="System.Keywords" content="conversiones de tipos de datos" /><meta name="Microsoft.Help.Id" content="98fa7488-aac3-45b4-8aa4-83ed6ab638b4" /><meta name="Description" content="Para facilitar la conversión de tipos de datos del lenguaje de programación Java a tipos de datos de SQL Server, el Controlador Microsoft JDBC para SQL Server proporciona las conversiones de tipos de datos que necesita la especificación JDBC." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Descripción de las conversiones de tipos de datos</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Para facilitar la conversión de tipos de datos del lenguaje de programación Java a tipos de datos de SQL Server, el Controlador Microsoft JDBC para SQL Server proporciona las conversiones de tipos de datos que necesita la especificación JDBC. Para mejorar la flexibilidad, todos los tipos son convertibles entre los tipos de datos <span sdata="langKeyword" value="Object"><span class="keyword">Object</span></span>, <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> y <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. </p></div><h1 class="heading">Conversiones de métodos de captador</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Según los tipos de datos SQL Server, el siguiente cuadro contiene el mapa de conversión del controlador JDBC para los métodos <b>get&lt;Type&gt;()</b> de la clase <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>, así como las conversiones no admitidas para los métodos <b>get&lt;Type&gt;</b> de la clase <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>.</p><img alt="JDBCGetterConversions" src="../art/JDBCGetterConversions.gif" /><p>Los métodos de captador del controlador JDBC admiten tres categorías de conversiones:</p><ul><li><p><span class="label">Sin pérdidas (x)</span>: conversiones para los casos en los que el tipo de captador es igual o menor que el tipo de servidor subyacente. Por ejemplo, al llamar a <b>getBigDecimal</b> en una columna decimal del servidor subyacente, no es necesario realizar ninguna conversión.</p></li><li><p><span class="label">Convertido (y)</span>: conversiones desde tipos de servidores numéricos a tipos del lenguaje Java en las que la conversión es normal y sigue las reglas de conversión del lenguaje Java. Para estas conversiones, la precisión siempre se trunca, nunca se redondea, y el desbordamiento se trata como un módulo del tipo de destino, que es más pequeño. Por ejemplo, al llamar a <b>getInt</b> en una columna <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> subyacente que contiene "1.9999", por ejemplo, se devolverá "1", o si el valor <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> subyacente es "3000000000", el valor <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> se desborda a "-1294967296".</p></li><li><p><span class="label">Dependiente de datos (z)</span>: las conversiones de tipos de caracteres subyacentes a tipos numéricos requieren que los tipos de caracteres contengan valores que se puedan convertir a ese tipo. No se realiza ninguna otra conversión. Si el valor es demasiado grande para el tipo de captador, el valor no es válido. Por ejemplo, si se llama a <b>getInt</b> en una columna varchar(50) que contiene "53", el valor se devuelve como un <span sdata="langKeyword" value="int"><span class="keyword">int</span></span>, pero si el valor subyacente es "xyz" o "3000000000", se genera un error.</p></li></ul><p>Si se llama a <b>getString</b> en un tipo de datos de columna <span sdata="langKeyword" value="binary"><span class="keyword">binary</span></span>, <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> o <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, el valor se devuelve como un valor de cadena hexadecimal.</p></div><h1 class="heading">Conversiones de métodos de actualización</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>Para los tipos de datos de Java pasados a los métodos <b>update&lt;Type&gt;()</b> de la clase <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a>, se aplican las conversiones siguientes.</p><img alt="JDBCUpdaterConversions" src="../art/JDBC_JDBCUpdatterConversions.gif" /><p>Los métodos de actualización del controlador JDBC admiten tres categorías de conversiones:</p><ul><li><p><span class="label">Sin pérdidas (x)</span>: conversiones para los casos en los que el tipo de actualización es igual o menor que el tipo de servidor subyacente. Por ejemplo, al llamar a <b>updateBigDecimal</b> en una columna decimal del servidor subyacente, no es necesario realizar ninguna conversión.</p></li><li><p><span class="label">Convertido (y)</span>: conversiones desde tipos de servidores numéricos a tipos del lenguaje Java en las que la conversión es normal y sigue las reglas de conversión del lenguaje Java. Para estas conversiones, la precisión siempre se trunca (nunca se redondea) y el desbordamiento se trata como un módulo del tipo de destino (el más pequeño). Por ejemplo, al llamar a <b>updateDecimal</b> en una columna <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> subyacente que contiene "1.9999", por ejemplo, se devolverá "1" o si el valor <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> subyacente es "3000000000", el valor <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> se desborda a "-1294967296".</p></li><li><p><span class="label">Dependiente de datos (z)</span>: las conversiones de tipos de datos de origen subyacentes a tipos de datos de destino requieren que los valores contenidos se puedan convertir a los tipos de destino. No se realiza ninguna otra conversión. Si el valor es demasiado grande para el tipo de captador, el valor no es válido. Por ejemplo, si se llama a <b>updateString</b> en una columna que contiene "53", la actualización se realiza correctamente, pero si el valor String subyacente es "foo" o "3000000000", se genera un error.</p></li></ul><p>Cuado se llama a <b>updateString</b> en un tipo de datos de columna <span sdata="langKeyword" value="binary"><span class="keyword">binary</span></span>, <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> o <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, controla el valor como un valor de cadena hexadecimal.</p><p>Cuando el tipo de datos de columna de SQL Server es <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, el valor de los datos debe ser un tipo <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> válido. Cuando se llama a los métodos <b>updateBytes</b>, <b>updateBinaryStream</b> o <b>updateBlob</b>, el valor de los datos debe ser la representación de la cadena decimal de los caracteres XML. Por ejemplo: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Tenga en cuenta que se necesita una marca de orden de bytes (BOM) si los caracteres XML están en codificaciones de caracteres específicos.</p></div><h1 class="heading">Conversiones del método establecedor</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>Para los tipos de datos de Java pasados a los métodos <b>set&lt;Type&gt;()</b> de la clase <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> y de la clase <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>, se aplican las siguientes conversiones.</p><img alt="JDBCSetterConversions" src="../art/JDBC_JDBCSetterConversions_v2.gif" /><p>El servidor intenta realizar las conversiones y devuelve errores si no lo consigue.</p><p>En el caso del tipo de datos <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>, si el valor supera la longitud de <span sdata="langKeyword" value="VARCHAR"><span class="keyword">VARCHAR</span></span>, se asigna a <span sdata="langKeyword" value="LONGVARCHAR"><span class="keyword">LONGVARCHAR</span></span>. Similarmente <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span> se asigna a <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span>, si el valor supera la longitud admitida de <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>. Lo mismo sucede para <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. Los valores mayores que <span sdata="langKeyword" value="VARBINARY"><span class="keyword">VARBINARY</span></span> se vuelven <span sdata="langKeyword" value="LONGVARBINARY"><span class="keyword">LONGVARBINARY</span></span>.</p><p>Los métodos de establecimiento del controlador JDBC admiten dos categorías de conversiones:</p><ul><li><p><span class="label">Sin pérdidas (x)</span>: conversiones para los casos numéricos en los que el tipo de establecedor es igual o menor que el tipo de servidor subyacente. Por ejemplo, al llamar a <b>setBigDecimal</b> en una columna <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> del servidor subyacente, no es necesario realizar ninguna conversión. En los casos de conversión de tipo numérico a carácter, el tipo de datos <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> de Java se convierte en <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>. Por ejemplo, si se llama a <b>setDouble</b> con el valor "53" en una columna varchar(50), se producirá un valor de carácter "53" en esa columna de destino.</p></li><li><p><span class="label">Convertido (y)</span>: conversiones de un tipo <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> de Java a un tipo <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> del servidor subyacente que es menor. Esta conversión es normal y sigue las convenciones de conversión de SQL Server. La precisión siempre se trunca, nunca se redondea, y el desbordamiento lanza un error de conversión no admitida. Por ejemplo, si se utiliza <b>updateDecimal</b> con un valor de "1,9999" en una columna subyacente de enteros, el resultado es "1" en la columna destino; pero si se pasa de "3000000000", el controlador lanzará un error.</p></li><li><p><span class="label">Dependiente de datos (z)</span>: las conversiones de un tipo <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> de Java al tipo de datos subyacente de SQL Server dependen de las siguientes condiciones: el controlador envía el valor <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> a SQL Server y SQL Server realiza las conversiones si es necesario. Si <b>sendStringParametersAsUnicode</b> se establece en true y el tipo de datos subyacente de SQL Server es <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server no permite la conversión de <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> a <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> y genera una excepción <b>SQLServerException</b>. Si sendStringParametersAsUnicode se establece en false y el tipo de datos subyacente de SQL Server es <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server permite la conversión de <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> a <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> y no genera ninguna excepción.</p></li></ul><p>SQL Server realiza las conversiones y devuelve los errores al controlador JDBC cuando hay problemas.</p><p>Cuando el tipo de datos de columna de SQL Server es <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, el valor de los datos debe ser un tipo <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> válido. Cuando se llama a los métodos <b>updateBytes</b>, <b>updateBinaryStream</b> o <b>updateBlob</b>, el valor de los datos debe ser la representación de la cadena decimal de los caracteres XML. Por ejemplo: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Tenga en cuenta que se necesita una marca de orden de bytes (BOM) si los caracteres XML están en codificaciones de caracteres específicos.</p></div><h1 class="heading">Conversiones en setObject</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>Para los datos de tipo Java pasados a los métodos <b>setObject(&lt;Type&gt;)</b> de la clase <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a>, se aplican las conversiones siguientes. </p><img alt="JDBCSetObjectConversions" src="../art/JDBC_JDBCSetObjectConversions.gif" /><p>El método <b>setObject</b> sin un tipo de destino especificado usará la asignación predeterminada. En el caso del tipo de datos <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>, si el valor supera la longitud de <span sdata="langKeyword" value="VARCHAR"><span class="keyword">VARCHAR</span></span>, se asigna a <span sdata="langKeyword" value="LONGVARCHAR"><span class="keyword">LONGVARCHAR</span></span>. Similarmente <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span> se asigna a <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span>, si el valor supera la longitud admitida de <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>. Lo mismo sucede para <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. Los valores mayores que <span sdata="langKeyword" value="VARBINARY"><span class="keyword">VARBINARY</span></span> se vuelven <span sdata="langKeyword" value="LONGVARBINARY"><span class="keyword">LONGVARBINARY</span></span>.</p><p>Los métodos setObject del controlador JDBC admiten tres categorías de conversiones:</p><ul><li><p><span class="label">Sin pérdidas (x)</span>: conversiones para los casos numéricos en los que el tipo de establecedor es igual o menor que el tipo de servidor subyacente. Por ejemplo, al llamar a <b>setBigDecimal</b> en una columna <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> del servidor subyacente, no es necesario realizar ninguna conversión. En los casos de conversión de tipo numérico a carácter, el tipo de datos <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> de Java se convierte en <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>. Por ejemplo, si se llama a <b>setDouble</b> con el valor "53" en una columna varchar(50), se producirá un valor de carácter "53" en esa columna de destino.</p></li><li><p><span class="label">Convertido (y)</span>: conversiones de un tipo <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> de Java a un tipo <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> del servidor subyacente que es menor. esta conversión es normal y sigue las convenciones de conversión de SQL Server. La precisión siempre se trunca, nunca se redondea, y el desbordamiento lanza un error de conversión no admitida. Por ejemplo, si se utiliza <b>updateDecimal</b> con un valor de "1,9999" en una columna subyacente de enteros, el resultado es "1" en la columna destino; pero si se pasa de "3000000000", el controlador lanzará un error.</p></li><li><p><span class="label">Dependiente de datos (z)</span>: las conversiones de un tipo <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> de Java al tipo de datos subyacente de SQL Server dependen de las siguientes condiciones: el controlador envía el valor <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> a SQL Server y SQL Server realiza las conversiones si es necesario. Si la propiedad de conexión <b>sendStringParametersAsUnicode</b> se establece en true y el tipo de datos subyacente de SQL Server es <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server no permite la conversión de <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> a <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> y genera una excepción SQLServerException. Si <b>sendStringParametersAsUnicode</b> se establece en false y el tipo de datos subyacente de SQL Server es <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server permite la conversión de <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> a <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> y no genera ninguna excepción.</p></li></ul><p>SQL Server realiza el grueso de las conversiones de establecimiento y devuelve errores al controlador JDBC cuando encuentra problemas. Las conversiones del lado cliente son la excepción y solamente se realizan en el caso de los valores <span sdata="langKeyword" value="date"><span class="keyword">date</span></span>, <span sdata="langKeyword" value="time"><span class="keyword">time</span></span>, <span sdata="langKeyword" value="timestamp"><span class="keyword">timestamp</span></span>, <span sdata="langKeyword" value="Boolean"><span class="keyword">Boolean</span></span> y <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>.</p><p>Cuando el tipo de datos de columna de SQL Server es <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, el valor de los datos debe ser un tipo <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span> válido. Cuando se llama a los métodos setObject(byte[], SQLXML), setObject(inputStream, SQLXML) o setObject(Blob, SQLXML), el valor de los datos debería ser una representación de cadena hexadecimal de los caracteres XML. Por ejemplo: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Tenga en cuenta que se necesita una marca de orden de bytes (BOM) si los caracteres XML están en codificaciones de caracteres específicos.</p></div><span id="seeAlsoSpan"><h1 class="heading">Vea también</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Describir los tipos de datos del controlador JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Enviar <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dLe%20agradecemos%20sus%20comentarios.%20Los%20equipos%20de%20desarrolladores%20usan%20estos%20comentarios%20para%20mejorar%20la%20documentación.%20Mientras%20revisamos%20los%20comentarios,%20es%20posible%20que%20le%20enviemos%20un%20correo%20electrónico%20para%20solicitarle%20alguna%20aclaración%20o%20comentarios%20sobre%20una%20posible%20solución.%20No%20usamos%20su%20dirección%20de%20correo%20electrónico%20para%20ningún%20otro%20propósito%20y%20ésta%20se%20borra%20una%20vez%20finalizada%20la%20revisió.%0\APara%20obtener%20más%20información%20acerca%20de%20las%20directivas%20de%20privacidad%20de%20Microsoft,%20vea%20http://privacy.microsoft.com/es-es/default.aspx.%0\A%0\d','Comentarios%20del cliente');">comentarios de </a> acerca de este tema Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Todos los derechos reservados.</a></p></span></div></div></body></html>