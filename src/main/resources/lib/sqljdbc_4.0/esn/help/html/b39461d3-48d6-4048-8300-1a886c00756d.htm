<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Usar tipos de datos avanzados</title><meta name="Language" content="es-es" /><meta name="System.Keywords" content="tipos de datos avanzados" /><meta name="Microsoft.Help.Id" content="b39461d3-48d6-4048-8300-1a886c00756d" /><meta name="Description" content="El Controlador Microsoft JDBC para SQL Server usa los tipos de datos avanzados de JDBC para convertir los tipos de datos de SQL Server a un formato que el lenguaje de programación Java pueda entender." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Usar tipos de datos avanzados</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>El Controlador Microsoft JDBC para SQL Server usa los tipos de datos avanzados de JDBC para convertir los tipos de datos de SQL Server a un formato que el lenguaje de programación Java pueda entender. </p></div><h1 class="heading">Notas</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>La siguiente tabla muestra las asignaciones predeterminadas entre los tipos de datos de SQL Server avanzados, JDBC y del lenguaje de programación Java.</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Tipos de SQL Server</p></th><th><p>Tipos de JDBC (Tipos de java.sql.)</p></th><th><p>Tipos de lenguaje Java</p></th></tr><tr><td><p>varbinary(max)</p><p>image</p></td><td><p>LONGVARBINARY</p></td><td><p>byte[] (default), Blob, InputStream, String</p></td></tr><tr><td><p>text</p><p>varchar(max)</p></td><td><p>LONGVARCHAR</p></td><td><p>String (default), Clob, InputStream</p></td></tr><tr><td><p>ntext</p><p>nvarchar(max)</p></td><td><p>LONGVARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String (default), Clob, NClob (Java SE 6.0)</p></td></tr><tr><td><p>xml</p></td><td><p>LONGVARCHAR</p><p>SQLXML (Java SE 6.0)</p></td><td><p>String (default), InputStream, Clob, byte[],Blob, SQLXML (Java SE 6.0)</p></td></tr><tr><td><p>udt</p></td><td><p>VARBINARY</p></td><td><p>String (default), byte[], InputStream</p></td></tr></table></div><p>Las siguientes secciones proporcionan ejemplos de cómo puede usar el controlador JDBC y los tipos de datos avanzados.</p></div><h1 class="heading">Tipos de datos BLOB, CLOB y NCLOB</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>El controlador JDBC implementa todos los métodos de las interfaces java.sql.Blob, java.sql.Clob y java.sql.NClob. </p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Los valores CLOB se pueden usar con tipos de datos de valores grandes de SQL Server 2005 (o versiones posteriores). Específicamente, los tipos CLOB se pueden usar con los tipos de datos <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span> y <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>, los tipos BLOB se pueden usar con los tipos de datos <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> y <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> y los tipos NCLOB se pueden usar con <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> y <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div></div><h1 class="heading">Tipos de datos de valores grandes</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>En versiones anteriores de SQL Server, el trabajo con tipos de datos de valores grandes requería un tratamiento especial. Los tipos de datos de valores grandes son aquellos que superan el tamaño máximo de fila, 8 KB.SQL Server introduce un especificador máximo para los tipos de datos <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span>, <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> y <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span> para permitir el almacenamiento de valores de hasta 2^31 bytes. Las columnas de tablas y las variables Transact-SQL pueden especificar los tipos de datos <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span>, <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span> o <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>.</p><p>Los escenarios principales en los que se trabaja con tipos de valores grandes implican su recuperación de una base de datos o agregarlos a una base de datos. Las siguientes secciones describen diferentes enfoques para realizar estas tareas.</p><h1 class="heading">Recuperar tipos de valores grandes de una base de datos</h1><div class="subsection"><p>Al recuperar un tipo de datos de valores grandes, que no sean binarios, de una base de datos, como el tipo de datos <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span>, un planteamiento es leer esos datos como un flujo de caracteres. En el siguiente ejemplo, se usa el método <a href="599cf463-e19f-4baa-bacb-513cad7c6cd8.htm">executeQuery</a> de la clase <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> para recuperar datos de la base de datos y devolverlos como un conjunto de resultados. A continuación, se usa el método <a href="c70e210f-0288-47cc-9268-a29c45979729.htm">getCharacterStream</a> de la clase <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> para leer los datos de valores grandes en el conjunto de resultados.</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT TOP 1 * FROM Test1");
rs.next();
Reader reader = rs.getCharacterStream(2);</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Este mismo enfoque también se puede utilizar para los tipos de datos <span sdata="langKeyword" value="text"><span class="keyword">text</span></span>, <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> y <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div><p>Al recuperar tipos de datos binarios de valores grandes, de una base de datos, como el tipo de datos <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>, hay varios enfoques que se pueden aplicar. El enfoque más eficaz es leer los datos como un flujo binario, como en el siguiente ejemplo:</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
rs.next();
InputStream is = rs.getBinaryStream(2);</pre></span></div><p>También puede usar el método <a href="d16a0aea-6144-4fcb-bcbc-5d7daa36d327.htm">getBytes</a> para leer los datos como una matriz de bytes, como en el siguiente ejemplo:</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
rs.next();
byte [] b = rs.getBytes(2);</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>También puede leer los datos como un BLOB. No obstante, éste es el método menos eficaz de los dos que se han mostrado anteriormente.</p></div></div><h1 class="heading">Agregar tipos de valores grandes a una base de datos</h1><div class="subsection"><p>La carga de datos grandes con el controlador JDBC funciona bien para los casos en que tienen el tamaño de la memoria y, en los casos en los que son más grandes que la memoria, la transmisión de datos es la opción principal. No obstante, la manera más eficaz de cargar datos grandes es mediante interfaces de transmisión de datos.</p><p>Otra opción es usar un String o bytes, como se puede ver en el siguiente ejemplo:</p><div class="sampleCode"><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (c1_id, c2_vcmax) VALUES (?, ?)");
pstmt.setInt(1, 1);
pstmt.setString(2, htmlStr);
pstmt.executeUpdate();</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>Este enfoque también se puede utilizar para los valores que están almacenados en columnas <span sdata="langKeyword" value="text"><span class="keyword">text</span></span>, <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> y <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>.</p></div><p>Si tiene en el servidor una biblioteca de imágenes y debe cargar archivos binarios completos en una columna <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>, el método más eficaz con el controlador JDBC es usar directamente secuencias, como en el siguiente ejemplo:</p><div class="sampleCode"><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (Col1, Col2) VALUES(?,?)");
File inputFile = new File("CLOBFile20mb.jpg");
FileInputStream inStream = new FileInputStream(inputFile);
int id = 1;
pstmt.setInt(1,id);
pstmt.setBinaryStream(2, inStream);
pstmt.executeUpdate();
inStream.close();</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>El método CLOB o BLOB no es una forma eficaz de cargar grandes volúmenes de datos.</p></div></div><h1 class="heading">Modificación de tipos de valores grandes en una base de datos</h1><div class="subsection"><p>En la mayoría de los casos, el método recomendado para cargar o modificar valores grandes de una base de datos es pasar parámetros a través de las clases <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> y <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a> usando comandos de Transact-SQL del tipo UPDATE, WRITE y SUBSTRING.</p><p>Si tiene que reemplazar la instancia de una palabra en un archivo grande de texto, como un archivo de almacenamiento HTML, puede usar un objeto <b>Clob</b>, como en el siguiente ejemplo:</p><div class="sampleCode"><span codeLanguage="other"><pre>String SQL = "SELECT * FROM test1;";
Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
ResultSet rs = stmt.executeQuery(SQL);
rs.next();

Clob clob = rs.getClob(2);
long pos = clob.position("dog", 1);
clob.setString(pos, "cat");
rs.updateClob(2, clob);
rs.updateRow();</pre></span></div><p>Además, podría hacer el trabajo en el servidor y pasar los parámetros a una instrucción UPDATE preparada.</p><p>Para obtener más información sobre tipos de valores grandes, consulte "Uso de tipos de valores grandes" en los Libros en pantalla de SQL Server.</p></div></div><h1 class="heading">Tipos de datos XML</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>SQL Server proporciona un tipo de datos <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> que le permite almacenar documentos y fragmentos XML en una base de datos de SQL Server. El tipo de datos <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> es un tipo de datos integrado de SQL Server y en cierta forma es similar a otros tipos integrados como <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> y <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span>. Como sucede con otros tipos integrados, puede usar el tipo de datos <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> como un tipo de columna cuando crea una tabla, como tipo de variable, tipo de parámetro o tipo de devolución de función, o en funciones CAST y CONVERT de Transact-SQL.</p><p>En el controlador JDBC, el tipo de datos <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> se puede asignar como una cadena, una matriz de bytes, un flujo o un objeto CLOB, BLOB o SQLXML. Cadena es la asignación predeterminada. Desde la versión 2.0 del controlador JDBC, este controlador proporciona compatibilidad con la API de JDBC 4.0, que presenta la interfaz SQLXML. La interfaz SQLXML define métodos para interactuar con los datos XML y manipularlos. El tipo de datos <span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span> se asigna al tipo de datos <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> de SQL Server. Para obtener más información acerca de cómo leer y escribir datos XML desde y en una base de datos relacional con el tipo de datos Java de  <span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span>, vea <span sdata="link"><a href="32b7217e-1f0c-473d-9a45-176daa81584e.htm">Compatibilidad con datos XML</a></span>.</p><p>La implementación de los tipos de datos <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> del controlador JDBC proporciona compatibilidad para lo siguiente:</p><ul><li><p>Acceso a XML como una cadena UTF-16 estándar de Java para la mayoría de las situaciones comunes de programación.</p></li><li><p>Compatibilidad con la escritura de UTF-8 y otros XML codificados de 8 bits.</p></li><li><p>Acceso a XML como una matriz de bytes con un BOM inicial, cuando está codificado en UTF-16 para el intercambio con otros procesadores de XML y archivos en discos.</p></li></ul><p>SQL Server requiere un BOM inicial para XML codificado en UTF-16. La aplicación debe proporcionarlo cuando se suministran valores de parámetros XML como matrices de bytes. SQL Server siempre produce valores XML como cadenas de UTF-16 sin BOM o declaración de codificación integrada. Cuando se recuperan valores XML como byte[], BinaryStream o Blob, se agrega al principio del valor un BOM de UTF-16.</p><p>Para obtener más información acerca de los tipos de datos <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span>, vea "Tipos de datos XML" en los Libros en pantalla de SQL Server.</p></div><h1 class="heading">Tipos de datos definidos por el usuario</h1><div id="sectionSection4" class="section" name="collapseableSection" style=""><p>La introducción de tipos definidos por el usuario (UDT) en SQL Server 2005 amplia el sistema de tipos de SQL al permitirle almacenar estructuras de datos y objetos personalizados en una base de datos SQL Server. Los UDTs pueden contener múltiples tipos de datos y tener comportamientos, lo que los diferencia de los tipos de datos de alias tradicionales que se componen de un solo tipo de datos de sistema SQL Server. Los UDT se definen con cualquiera de los lenguajes compatibles con Microsoft .NET Common Language Runtime (CLR)  que producen código comprobable. Esto incluye Microsoft Visual C# y Visual Basic .NET. Los datos se exponen como campos y propiedades de una clase o una estructura basada en .NET Framework, y los comportamientos se definen con métodos de la clase o la estructura. </p><p>En SQL Server, se pueden usar los UDT como definiciones de columnas de una tabla, como una variable de un lote de Transact-SQL o como un argumento de una función o un procedimiento almacenado de Transact-SQL.</p><p>Para obtener más información acerca de los tipos de datos definidos por el usuario, consulte "Usar y modificar instancias de tipos definidos por el usuario" en los Libros en pantalla de SQL Server.</p></div><span id="seeAlsoSpan"><h1 class="heading">Vea también</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Describir los tipos de datos del controlador JDBC</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Enviar <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dLe%20agradecemos%20sus%20comentarios.%20Los%20equipos%20de%20desarrolladores%20usan%20estos%20comentarios%20para%20mejorar%20la%20documentación.%20Mientras%20revisamos%20los%20comentarios,%20es%20posible%20que%20le%20enviemos%20un%20correo%20electrónico%20para%20solicitarle%20alguna%20aclaración%20o%20comentarios%20sobre%20una%20posible%20solución.%20No%20usamos%20su%20dirección%20de%20correo%20electrónico%20para%20ningún%20otro%20propósito%20y%20ésta%20se%20borra%20una%20vez%20finalizada%20la%20revisió.%0\APara%20obtener%20más%20información%20acerca%20de%20las%20directivas%20de%20privacidad%20de%20Microsoft,%20vea%20http://privacy.microsoft.com/es-es/default.aspx.%0\A%0\d','Comentarios%20del cliente');">comentarios de </a> acerca de este tema Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft. Todos los derechos reservados.</a></p></span></div></div></body></html>